#include "thread_pool.hpp"

std::atomic<int> i = 0;
enum { COUNT = 150 };
std::latch l(COUNT);

dd::job foo(dd::thread_pool& p) {
  while (true) {
    auto x = i.fetch_add(1, std::memory_order::acq_rel);
    if (x >= 100'000)
      break;
    co_await p.execute();
  }
  l.count_down();
}
// TODO тесты с другими стратегиями выбора и тд
int main() {
  dd::thread_pool p(16);

  for (int i = 0; i < COUNT; ++i) {
    foo(p);
  }
  // TODO хм, может быть прикол в том что переезжает на разные треды таска и это долго? Сделать стренд
  // если так, то пиздец какой смысл появляется в оптимизации момента, что таска пушит на тредпул и уже
  // находится на нём и тогда нужно просто в тот же тред положить(или вовсе ничего не складывать)
  // некий auto strand получается
  // и это тоже часть стратегии выбора (select worker)
  // в случае корутины это вообще можно делать в самом эвейте!! И просто ВОЗВРАЩАТЬ ей же управление!
  // и так решается проблема рекурсии(возможно не для всех компиляторов), вполне годно!
  // но есть проблема, что нарушается порядок исполнения, это не очередь уже, некоторые таски не исполнятся..
  // нужно это делать видимо если очередь пустая... Хм
  // foo(p);

  // TODO есть плагин - профайлер под ввскод? Непонятно где время пропаает
  l.wait();
  if (i.load() < 100'000)
    return -1;
  return 0;
}
